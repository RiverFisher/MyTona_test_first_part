Функцию f() невозможно вызвать, поскольку уже есть функция f(int a = 0), сигнатура которой
удовлетворяет сигнатуре функции f(). Начальная инициализация аргумента в скобках сообщает
компилятору, что аргумент a не обязательный для передачи в момент вызова функции. Таким образом,
сигнатура функции f() является неполным эквивалентом сигнатуры функции f(int a = 0), что не даёт
компилятору определить, какую функцию необходимо вызывать.

Для разрешения конфликта предложу два простейших варианта.

1) Достаточно избавить функцию f(int a = 0) от не обязательного аргумента:
// f(int a) {
// ...
В этом случае компилятор воспримет функции как разные по сигнатуре, и функция f будет являться
перегруженной.

2) Достаточно вообще удалить функцию f(), поскольку для функции f(int a = 0) допустим вызов
f(). В этом случае необходимо убедиться, что для вызова f() - имею ввиду f(int a = 0)
без аргументов - будет выполнено тело удалённой функции f(). Возможно, придётся расширить тело
функции f(int a = 0) для этого случая. Но если при этом будет нарушена логика внутри функции,
этот способ не следует использовать. Пояснение ниже:
// void f() {    <-- удалить
//     some code <-- перенести логику в f(int a = 0) для значения по умолчанию (без аргументов)
// }             <-- удалить
//
// void f(int a = 0) {
//     if (a = 0) {
//         some code from f()
//     } else {
//         some code
//     }
// }

Также можно предложить решения, основанные на использовании namespace'ов,
множественного наследования с использованием виртуальных функций (в этом случае будет сокрытие
функции f(), и ошибки не будет), - но эти решения подразумевают, что нужно обращаться к
функции f() через экземпляр структуры / класса или через указание пространства имён. В примерах
выше используются глобальные функции, и не требуют таких указаний для доступа к ним. Поэтому я
рассматриваю решения выше универсальными, а остальные решения (о которых я упомянул) -
действующими в контексте структур / классов или пространств имён. И считаю, что в рамках решения
данного задания следует предлагать только универсальные решения.
